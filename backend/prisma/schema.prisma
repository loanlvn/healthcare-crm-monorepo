// prisma/schema.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum Role {
  ADMIN
  DOCTOR
  SECRETARY
}

enum MsgStatus {
  READ
  UNREAD
}

enum MsgType {
  ALERT
  REMINDER
  NOTE
}

enum ApptStatus {
  SCHEDULED
  CONFIRMED
  CANCELLED
  NO_SHOW
  DONE
}

enum Currency {
  EUR
}

enum InvoiceStatus {
  DRAFT
  SENT
  PAID
  PARTIALLY_PAID
  VOID
}

enum PayMethod {
  CASH
  CARD
  TRANSFER
  CHECK
}

enum NotifType {
  APPOINTMENT_REMINDER
  MESSAGE_NEW
  INVOICE_SENT
  PAYMENT_RECEIVED
}

enum NotifChannel {
  IN_APP
  EMAIL
}

enum NotifStatus {
  PENDING
  SENT
  READ
}

enum ConversationType {
  PATIENT
  INTERNAL
}

enum ReminderStatus {
  PENDING
  SENT
  CANCELLED
  FAILED
}

model User {
  id                 String    @id @default(uuid())
  email              String    @unique
  passwordHash       String
  firstName          String
  lastName           String
  role               Role
  isActive           Boolean   @default(true)
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  avatarUrl          String?
  avatarUpdatedAt    DateTime?
  mustChangePassword Boolean   @default(true)

  patientsOwned  Patient[]       @relation("OwnerPatients")
  appointments   Appointment[]   @relation("DoctorAppointments")
  invoicesIssued Invoice[]       @relation("Issuer")
  messagesSent   Message[]       @relation("MessageSender")
  notifications  Notification[]
  auditLogs      AuditLog[]      @relation("Actor")
  refreshTokens  RefreshToken[]
  PasswordReset  PasswordReset[]
  PatientDoctor  PatientDoctor[]
  DoctorProfile  DoctorProfile?

  conversations   ConversationParticipant[]
  messageReceipts MessageReceipt[]
}

model PasswordReset {
  id          String    @id @default(uuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  codeHash    String // hash du code 6 chiffres
  expiresAt   DateTime // TTL du code
  verifiedAt  DateTime?
  completedAt DateTime?
  attempts    Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model Patient {
  id              String    @id @default(uuid())
  firstName       String
  lastName        String
  birthDate       DateTime?
  phone           String?
  email           String?
  address         String?
  assuranceNumber String?
  doctorName      String?
  notes           String?
  ownerId         String
  owner           User      @relation("OwnerPatients", fields: [ownerId], references: [id])
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  isDeleted Boolean   @default(false)
  deletedAt DateTime?

  doctors PatientDoctor[]

  appointments Appointment[]
  invoices     Invoice[]
  Conversation Conversation[]

  // Indexes
  @@index([ownerId], map: "idx_patient_owner_id")
  @@index([isDeleted])
  @@index([lastName, firstName])
}

model PatientDoctor {
  patientId  String
  doctorId   String // référence User.id (role = DOCTOR)
  specialty  String?
  primary    Boolean  @default(false)
  assignedAt DateTime @default(now())
  assignedBy String?

  patient Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)
  doctor  User    @relation(fields: [doctorId], references: [id])

  @@id([patientId, doctorId])
  @@index([doctorId])
}

model DoctorProfile {
  userId      String   @id
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  specialties String[] // Postgres
  bio         String?
  phone       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Conversation {
  id            String           @id @default(uuid())
  type          ConversationType
  patientId     String?
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  lastMessageAt DateTime?

  patient      Patient?                  @relation(fields: [patientId], references: [id])
  participants ConversationParticipant[]
  messages     Message[]

  @@index([type])
  @@index([patientId], map: "idx_conversation_patient_id")
  @@index([lastMessageAt], map: "idx_conversation_last_message_at")
}

model ConversationParticipant {
  conversationId String
  userId         String
  roleAtJoin     Role?
  joinedAt       DateTime  @default(now())
  lastReadAt     DateTime?

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([conversationId, userId])
  @@index([userId], map: "idx_convparticipant_user_id")
}

model MessageReceipt {
  messageId String
  userId    String
  readAt    DateTime?

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([messageId, userId])
  @@index([userId], map: "idx_messagereceipt_user_id")
}

model Message {
  id             String   @id @default(uuid())
  conversationId String
  senderId       String
  content        String
  type           MsgType  @default(NOTE)
  attachments    Json?
  createdAt      DateTime @default(now())

  conversation Conversation     @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User             @relation("MessageSender", fields: [senderId], references: [id])
  receipts     MessageReceipt[]

  @@index([conversationId, createdAt], map: "idx_message_conversation_created_at")
}

model Appointment {
  id        String     @id @default(uuid())
  patientId String
  doctorId  String
  startsAt  DateTime
  endsAt    DateTime
  reason    String?
  status    ApptStatus @default(SCHEDULED)
  location  String?
  notes     String?
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  patient             Patient              @relation(fields: [patientId], references: [id])
  doctor              User                 @relation("DoctorAppointments", fields: [doctorId], references: [id])
  invoice             Invoice?
  AppointmentReminder AppointmentReminder?

  // Indexes
  @@index([doctorId], map: "idx_appointment_doctor_id")
  @@index([patientId], map: "idx_appointment_patient_id")
}

model AppointmentReminder {
  id            String         @id @default(uuid())
  appointmentId String         @unique // 1 rappel T-24h par RDV
  scheduledAt   DateTime // startsAt - 24h
  status        ReminderStatus @default(PENDING)
  sentAt        DateTime?
  lastError     String?
  retryCount    Int            @default(0)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  appointment Appointment @relation(fields: [appointmentId], references: [id])

  @@index([scheduledAt], map: "idx_reminder_scheduled")
}

model Invoice {
  id            String        @id @default(uuid())
  patientId     String
  appointmentId String?       @unique
  issuerId      String
  number        String        @unique
  date          DateTime
  items         Json // [{label, qty, unitPrice, taxRate}]
  subtotal      Decimal       @db.Decimal(12, 2)
  taxTotal      Decimal       @db.Decimal(12, 2)
  total         Decimal       @db.Decimal(12, 2)
  currency      Currency      @default(EUR)
  status        InvoiceStatus @default(DRAFT)
  pdfUrl        String?
  sentAt        DateTime?
  paidAt        DateTime?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  patient     Patient      @relation(fields: [patientId], references: [id])
  appointment Appointment? @relation(fields: [appointmentId], references: [id])
  issuer      User         @relation("Issuer", fields: [issuerId], references: [id])
  payments    Payment[]

  // Indexes
  @@index([patientId], map: "idx_invoice_patient_id")
}

model Payment {
  id        String    @id @default(uuid())
  invoiceId String
  amount    Decimal   @db.Decimal(12, 2)
  method    PayMethod
  paidAt    DateTime
  reference String?
  createdAt DateTime  @default(now())

  invoice Invoice @relation(fields: [invoiceId], references: [id])
}

model Notification {
  id        String       @id @default(uuid())
  userId    String
  type      NotifType
  payload   Json
  channel   NotifChannel @default(IN_APP)
  status    NotifStatus  @default(PENDING)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  user User @relation(fields: [userId], references: [id])

  // Indexes
  @@index([userId], map: "idx_notification_user_id")
}

model AuditLog {
  id         String   @id @default(uuid())
  actorId    String
  action     String
  targetType String
  targetId   String
  metadata   Json?
  createdAt  DateTime @default(now())

  actor User @relation("Actor", fields: [actorId], references: [id])
}

model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  userAgent String?
  ip        String?
  revoked   Boolean  @default(false)
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])

  // Indexes
  @@index([userId], map: "idx_refreshtoken_user_id")
}
